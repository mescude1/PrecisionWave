\documentclass{article}
\usepackage{minted}
\usepackage{textcomp}

\title{EAFIT University - Department of Information and Computer Sciences}
\author{Mauricio Escudero Restrepo \\
        César Esteban Peñuela Cubides \\
        Diego Mesa Ospina}
\date{August 2024}

\begin{document}

\maketitle

\section{Objetivo}
Review the progress of the final project and the work methodologies of the workgroups

\section{Course}
Numerical Analisis

\section{Responsible Faculty Member}
Edwar Samir Posada Murillo

\section{Current Report Delivery Date}
October 1st 2024
    
\section[]{Numerical Methods}
    The following numerical methods will be presented in this document in the following manner, first a pseudocode 
    version of the method algorith will be presented, after the code for the implementation of the method in both 
    languages selected will be presented, finally proof for the execution and results of the methods will be provided.
    
    \subsection{Incremental Search}

    Incremental Search Method is a numerical method used to find the roots of a function
    (i.e., where the function equals zero).
    This method works by iteratively narrowing down an interval where a root
    lies.
    The goal is to find an approximation of the root with increasing precision.

        \subsubsection{Pseudo-code}

            \subsubsection{Method Implementation}

                \paragraph{Python}

    \begin{minted}{python}
        def incremental_search(f, x0, h, Nmax):
            """
            This program finds an interval where f(x) has a sign change using the incremental search method.
            Inputs:
            f: continuous function
            x0: initial point
            h: step
            Nmax: maximum number of iterations

            Outputs:
            a: left endpoint of the interval
            b: right endpoint of the interval
            iter: number of iterations
            """

            # Initialization

            xant = x0
            fant = f(xant)
            xact = xant + h
            fact = f(xact)
            result_array = []
            # Loop
            for i in range(1, Nmax+1):
                if fant * fact < 0:
                    result = {
                        'i': i,
                        'x_i': xact,
                        'f_xi': fact,
                        'e': abs(xact - xant)
                    }
                    result_array.append(result)
                    break
                result = {
                    'i': i,
                    'x_i': xact,
                    'f_xi': fact,
                    'e': abs(xact - xant)
                }
                result_array.append(result)
                xant = xact
                fant = fact
                xact = xant + h
                fact = f(xact)

            # Result delivery

            a = xant
            b = xact
            iter = i
            result_data_frame = pd.DataFrame(result_array)
            return a, b, iter, result_data_frame
        \end{minted}

    \paragraph{Rust}\label{paragraph:rust}

    \begin{minted}{Rust}
        use std::f64::EPSILON;

        // Define a struct to hold the result for each iteration
        #[derive(Debug)]
        struct SearchResult {
            iteration: usize,
            x_i: f64,
            f_xi: f64,
            error: f64,
        }

        // Function for incremental search in Rust
        fn incremental_search<F>(f: F, x0: f64, h: f64, nmax: usize) -> (f64, f64, usize, Vec<SearchResult>)
        where
            F: Fn(f64) -> f64,
        {
            // Initialization
            let mut xant = x0;
            let mut fant = f(xant);
            let mut xact = xant + h;
            let mut fact = f(xact);

            // Create a Vec to store the results
            let mut result_array: Vec<SearchResult> = Vec::new();

            // Iteration variable
            let mut iterations = 0;

            // Loop
            for i in 1..=nmax {
                iterations = i;

                // Store the current iteration result
                let result = SearchResult {
                    iteration: i,
                    x_i: xact,
                    f_xi: fact,
                    error: (xact - xant).abs(),
                };
                result_array.push(result);

                // Check for sign change
                if fant * fact < 0.0 {
                    break;
                }

                // Update
                xant = xact;
                fant = fact;
                xact = xant + h;
                fact = f(xact);

                // Stopping condition if the step size is too small
                if (xact - xant).abs() < EPSILON {
                    break;
                }
            }

            // Return the result: interval endpoints, number of iterations, and the results array
            (xant, xact, iterations, result_array)
        }
    \end{minted}

    \subsubsection{Method Tests}\label{subsec:method-tests}

The test parameters are as follows:
        - \textflorin = math.log((math.sin(x)**2) + 1 ) - 1/2
        - x0 = -3
        - step = 0.5
        - Tol = 1x10-7
        - N = 100

    Result:
        Interval: [-2.5, -2.0], Iterations: 2

        \begin{table}[ht]
        \begin{tabular}{llll}
        i & x\_i & f\_xi     & e   \\
        1 & -2.5 & -0.193863 & 0.5 \\
        2 & -2.0 & 0.102578  & 0.5
        \end{tabular}\label{tab:table}
        \end{table}

    \subsection{Bisection}\label{subsec:bisection}

    The bisection method is based on the Intermediate Value Theorem, which states that if a continuous function changes
    sign over an interval, there is at least one root in that interval. The method systematically reduces the interval
    in which the root lies by repeatedly bisecting it.

    \subsubsection{Pseudo-code}

    \subsubsection{Method Implementation}
    \paragraph{Python}

    \begin{minted}{Python}
        def bisection_method(f, a, b, tolerance=1e-7, max_iterations=100):
    """
    Bisection method to find the root of f(x) in the interval [a, b].

    Parameters:
    f : function
        The function for which we are trying to find a root.
    a, b : float
        The interval [a, b] in which the root is located.
    tolerance : float, optional
        The stopping criterion for the algorithm.
    max_iterations : int, optional
        The maximum number of iterations to perform.

    Returns:
    c : float
        The approximate root.
    iterations : int
        The number of iterations performed.
    converged : bool
        Whether the algorithm converged or not.
    """
    if f(a) * f(b) >= 0:
        raise ValueError("f(a) and f(b) must have opposite signs.")
    c = (a + b) / 2  # Midpoint initial
    result_array = []
    for i in range(max_iterations):
        c = (a + b) / 2  # Midpoint
        if abs(b - a) < tolerance or abs(f(c)) < tolerance:
            df_result = pd.DataFrame(data=result_array)
            print(df_result)
            return c, i + 1, True, df_result  # Converged

        # Narrow the interval based on the sign of f(c)
        if f(a) * f(c) < 0:
            b = c  # The root is in [a, c]
        else:
            a = c  # The root is in [c, b]

        result = {'i': i, 'x_i': c, 'f_x_i': f(c), 'e': abs(b - a)}
        result_array.append(result)

    return c, max_iterations, False  # Did not converge within max_iterations

    \end{minted}

    \paragraph{Rust}
    \begin{minted}{Rust}
        #[derive(Debug)]
struct BisectionResult {
    iteration: usize,
    x_i: f64,
    f_x_i: f64,
    error: f64,
}

// Bisection method function in Rust
fn bisection_method<F>(
    f: F,
    mut a: f64,
    mut b: f64,
    tolerance: f64,
    max_iterations: usize,
) -> (f64, usize, bool, Vec<BisectionResult>)
where
    F: Fn(f64) -> f64,
{
    // Check if f(a) and f(b) have opposite signs
    if f(a) * f(b) >= 0.0 {
        panic!("f(a) and f(b) must have opposite signs.");
    }

    // Create a Vec to store the results for each iteration
    let mut result_array: Vec<BisectionResult> = Vec::new();

    let mut c = (a + b) / 2.0; // Midpoint initialization

    // Bisection loop
    for i in 0..max_iterations {
        c = (a + b) / 2.0; // Midpoint

        // Check if the solution has converged
        if (b - a).abs() < tolerance || f(c).abs() < tolerance {
            return (c, i + 1, true, result_array); // Converged
        }

        // Narrow the interval based on the sign of f(c)
        if f(a) * f(c) < 0.0 {
            b = c; // The root is in [a, c]
        } else {
            a = c; // The root is in [c, b]
        }

        // Store the result of the current iteration
        let result = BisectionResult {
            iteration: i + 1,
            x_i: c,
            f_x_i: f(c),
            error: (b - a).abs(),
        };
        result_array.push(result);
    }

    // If the loop finishes without converging, return the last midpoint and results
    (c, max_iterations, false, result_array) // Did not converge within max_iterations
}
    \end{minted}

\subsubsection{Method Test}\label{subsec:method-test}
The test parameters are as follows:
        - \textflorin = math.log((math.sin(x)**2) + 1 ) - 1/2
        - a = 0
        - b = 1
        - Tol = 1x10-7
        - N = 100

    Result:
        - Root: 0.9364047050476074
        - Iterations: 21
        - Converged: True

\begin{table}[ht]
\begin{tabular}{llll}
i  & x\_i               & f\_x\_i                 & e                   \\
0  & 0.5                & -0.2931087267313766     & 0.5                 \\
1  & 0.75               & -0.11839639385347844    & 0.25                \\
2  & 0.875              & -0.036817690757380506   & 0.125               \\
3  & 0.9375             & 0.0006339161592386899   & 0.0625              \\
4  & 0.90625            & -0.017772289226861138   & 0.03125             \\
5  & 0.921875           & -0.008486582211768012   & 0.015625            \\
6  & 0.9296875          & -0.0039053586270640928  & 0.0078125           \\
7  & 0.93359375         & -0.0016304381170096915  & 0.00390625          \\
8  & 0.935546875        & -0.0004969353153196909  & 0.001953125         \\
9  & 0.9365234375       & 6.882244496264622e-05   & 0.0009765625        \\
10 & 0.93603515625      & -0.00021397350516405567 & 0.00048828125       \\
11 & 0.936279296875     & -7.255478812057126e-05  & 0.000244140625      \\
12 & 0.9364013671875    & -1.860984900181606e-06  & 0.0001220703125     \\
13 & 0.93646240234375   & 3.348202684883006e-05   & 6.103515625e-05     \\
14 & 0.936431884765625  & 1.581084516011355e-05   & 3.0517578125e-05    \\
15 & 0.9364166259765625 & 6.975011174192858e-06   & 1.52587890625e-05   \\
16 & 0.9364089965820312 & 2.5570333977986692e-06  & 7.62939453125e-06   \\
17 & 0.9364051818847656 & 3.4802931392352576e-07  & 3.814697265625e-06  \\
18 & 0.9364032745361328 & -7.564765268641693e-07  & 1.9073486328125e-06 \\
19 & 0.9364042282104492 & -2.042232898902263e-07  & 9.5367431640625e-07
\end{tabular}\label{tab:table2}
    \end{table}

\subsection{False Rule}\label{subsec:false_rule}

The false position method (also known as the regula falsi method) is a root-finding technique used in numerical analysis.
It is similar to the bisection method in that it iteratively narrows down an interval where a root of a function exists.
However, instead of using the midpoint of the interval as in the bisection method, the false position method uses a
more refined estimate by linearly interpolating the function between the endpoints.

\subsubsection{Pseudo-code}

    \subsubsection{Method Implementation}
    \paragraph{Python}
     \begin{minted}{Python}
        import math
        import pandas as pd


        def false_rule(f, a, b, tol, Nmax):
            """
            This program finds the solution to the equation f(x) = 0 en el interval [a, b] using the method of the false rule

            Inputs:
            f: continious function
            a: left endpoint of the initial interval
            b: right endpoint of the initial interval
            tol: tolerance
            Nmax: maximum number of iterations

            Outputs:
            x: aproximate solution
            iter: number of iterations
            err: estimated error
            """
            # Initialization
            fa = f(a)
            fb = f(b)
            pm = (fb * a - fa * b) / (fb - fa)
            fpm = f(pm)
            E = 1000  # Initial large error
            cont = 1  # Iteration counted

            # loop of the false rule method
            result_array = []
            while E > tol and cont < Nmax:
                if fa * fpm < 0:
                    b = pm
                    fb = fpm
                else:
                    a = pm
                    fa = fpm


                # Updating previous point
                p0 = pm
                pm = (fb * a - fa * b) / (fb - fa)
                fpm = f(pm)
                E = abs(pm - p0)

                result = {
                    'i': cont,
                    'x_i': pm,
                    'f_xi': fpm,
                    'e': abs(pm - p0)
                }
                result_array.append(result)

                cont += 1

            # Results
            x = pm
            iter = cont
            err = E
            return x, iter, err, result_array

    \end{minted}

    \paragraph{Rust}

     \begin{minted}{Rust}
        // Define a struct to store results for each iteration
        #[derive(Debug)]
        struct FalsePositionResult {
            iteration: usize,
            a: f64,
            b: f64,
            x_new: f64,
            f_x_new: f64,
            error: f64,
        }

        // False Position method in Rust
        fn false_position<F>(
            f: F,
            mut a: f64,
            mut b: f64,
            tol: f64,
            max_iter: usize,
        ) -> (f64, Vec<FalsePositionResult>)
        where
            F: Fn(f64) -> f64,
        {
            // Check if f(a) and f(b) have opposite signs
            if f(a) * f(b) >= 0.0 {
                panic!("The function must have opposite signs at the endpoints a and b.");
            }

            // Create a Vec to store the results for each iteration
            let mut result_array: Vec<FalsePositionResult> = Vec::new();

            // False position method loop
            for i in 0..max_iter {
                // Calculate the new point using the false position formula
                let x_new = b - (f(b) * (b - a)) / (f(b) - f(a));
                let f_x_new = f(x_new);

                // Store the result of the current iteration
                let result = FalsePositionResult {
                    iteration: i + 1,
                    a,
                    b,
                    x_new,
                    f_x_new,
                    error: f_x_new.abs(),
                };
                result_array.push(result);

                // Check if the result is within the tolerance
                if f_x_new.abs() < tol {
                    return (x_new, result_array); // Converged
                }

                // Update the interval based on the sign of f(x_new)
                if f(a) * f_x_new < 0.0 {
                    b = x_new;
                } else {
                    a = x_new;
                }
            }

            // If no solution is found within the given number of iterations
            panic!("Maximum number of iterations reached without convergence.");
        }
     \end{minted}
    \subsubsection{Method Tests}

        Approximate solution:
            x = 0.9364045808798893
            Iterations: 5
            Error: 2.2097967899981086e-10

        \begin{table}[ht]
        \begin{tabular}{llll}
        i & x\_i               & f\_xi                  & e                      \\
        1 & 0.9365060516656253 & 5.875600835791861e-05  & 0.0025656709474095596  \\
        2 & 0.9364047307426415 & 8.67825411532408e-08   & 0.00010132092298376083 \\
        3 & 0.936404581100869  & 1.2815393191090152e-10 & 1.4964177252885236e-07 \\
        4 & 0.9364045808798893 & 1.894040480010517e-13  & 2.2097967899981086e-10
        \end{tabular}\label{tab:table3}
        \end{table}
\subsection{Fixed Point}\label{subsec:fixed_point}

The fixed-point method is an iterative numerical technique used to solve equations of the form x=g(x)x = g(x)x=g(x).
In this method, the goal is to find a value xxx such that g(x)=xg(x) = xg(x)=x, which is known as a fixed
point of the function g(x)g(x)g(x).

    \subsubsection{Pseudo-code}

    \subsubsection{Method Implementation}
    \paragraph{Python}

    \begin{minted}{Python}
        def fixed_point_interval(g, a, b, x0, tolerance=1e-7, max_iterations=100):
            """
            Fixed-point iteration method to solve x = g(x) on the interval [a, b].

            Parameters:
            g : function
                The function g(x) that defines the equation x = g(x).
            a, b : float
                The interval [a, b] in which the fixed point must lie.
            x0 : float
                Initial guess for the solution (must be within [a, b]).
            tolerance : float, optional
                The stopping criterion based on the change between iterations.
            max_iterations : int, optional
                The maximum number of iterations to perform.

            Returns:
            x : float
                The fixed-point solution (if found).
            iterations : int
                The number of iterations performed.
            converged : bool
                Whether the algorithm converged or not.
            """
            # Check if the initial guess is within the interval
            if not (a <= x0 <= b):
                raise ValueError("Initial guess x0 must be within the interval [a, b].")
            result_array = []
            x = x0
            for i in range(max_iterations):
                x_next = g(x)

                # Ensure that x_next stays within the interval [a, b]
                if x_next < a:
                    x_next = a
                elif x_next > b:
                    x_next = b

                # Check if the difference between consecutive iterations is within the tolerance
                if abs(x_next - x) < tolerance:
                    result = {
                        'i': i,
                        'x_i': x,
                        'f_xi': x_next,
                        'e': abs(x_next - x)
                    }
                    result_array.append(result)
                    print(DataFrame(result_array))
                    return x_next, i + 1, True  # Converged
                result = {
                    'i': i,
                    'x_i': x,
                    'f_xi': x_next,
                    'e': abs(x_next - x)
                }
                result_array.append(result)
                x = x_next

            return x, max_iterations, False  # Did not converge within max_iterations
    \end{minted}
    \paragraph{Rust}
    \begin{minted}{Rust}

    \end{minted}
\end{document}
